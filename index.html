<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Web Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0d1b2a;
            color: #f0f0f0;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
            user-select: none;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            padding: 12px 20px;
            background-color: rgba(13, 27, 42, 0.95);
            border-bottom: 3px solid #1b3a4b;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 28px;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }
        
        h1 {
            color: #4ecdc4;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 28px;
            letter-spacing: 1px;
        }
        
        .game-stats {
            display: flex;
            gap: 20px;
            font-size: 16px;
        }
        
        .stat-item {
            background-color: rgba(27, 58, 75, 0.7);
            padding: 6px 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stat-icon {
            color: #4ecdc4;
            font-weight: bold;
        }
        
        #main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        #sidebar {
            width: 280px;
            background-color: rgba(13, 27, 42, 0.95);
            border-right: 2px solid #1b3a4b;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            transition: transform 0.3s;
        }
        
        .sidebar-section {
            background-color: rgba(27, 58, 75, 0.6);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }
        
        .section-title {
            color: #4ecdc4;
            font-size: 18px;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 2px solid rgba(78, 205, 196, 0.5);
        }
        
        #inventory {
            min-height: 200px;
        }
        
        .inventory-slots {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .inventory-slot {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .inventory-slot:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: #4ecdc4;
        }
        
        .inventory-slot.selected {
            background-color: rgba(78, 205, 196, 0.2);
            border-color: #4ecdc4;
            transform: scale(1.05);
        }
        
        .slot-count {
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .block-preview {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            margin-bottom: 2px;
        }
        
        .slot-name {
            font-size: 10px;
            text-align: center;
            color: #ccc;
        }
        
        #crafting {
            min-height: 250px;
        }
        
        .crafting-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-bottom: 12px;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 8px;
            border-radius: 5px;
        }
        
        .crafting-slot {
            width: 45px;
            height: 45px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #craft-result {
            width: 55px;
            height: 55px;
            background-color: rgba(27, 58, 75, 0.8);
            border: 2px solid #4ecdc4;
            border-radius: 6px;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .craft-btn {
            width: 100%;
            padding: 10px;
            background-color: #1b6ca8;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .craft-btn:hover {
            background-color: #4ecdc4;
            transform: translateY(-2px);
        }
        
        .craft-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        #player-info {
            background-color: rgba(27, 58, 75, 0.7);
            padding: 12px;
            border-radius: 8px;
        }
        
        .health-bar, .food-bar {
            height: 18px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 9px;
            margin-bottom: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            border-radius: 9px;
            width: 100%;
            transition: width 0.3s;
        }
        
        .food-fill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            border-radius: 9px;
            width: 100%;
            transition: width 0.3s;
        }
        
        .bar-label {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            font-size: 12px;
        }
        
        #canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
        }
        
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            justify-content: space-between;
            z-index: 50;
        }
        
        .mobile-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            user-select: none;
            touch-action: none;
        }
        
        #toggle-sidebar {
            position: absolute;
            top: 80px;
            left: 10px;
            width: 35px;
            height: 35px;
            background-color: rgba(27, 58, 75, 0.9);
            border: 2px solid #4ecdc4;
            border-radius: 0 5px 5px 0;
            color: #4ecdc4;
            font-size: 18px;
            cursor: pointer;
            z-index: 99;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0d1b2a 0%, #1b3a4b 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        
        .loader {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(78, 205, 196, 0.2);
            border-top: 6px solid #4ecdc4;
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 20px;
            color: #4ecdc4;
            margin-bottom: 8px;
        }
        
        .loading-subtext {
            color: #89c2d9;
            margin-bottom: 20px;
        }
        
        .progress-bar {
            width: 250px;
            height: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #4ecdc4, #1b6ca8);
            border-radius: 8px;
            width: 0%;
            transition: width 0.3s;
        }
        
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 90;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 10px;
        }
        
        .hotbar-slot {
            width: 55px;
            height: 55px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s;
        }
        
        .hotbar-slot.selected {
            border-color: #4ecdc4;
            background-color: rgba(78, 205, 196, 0.2);
            transform: translateY(-3px);
        }
        
        .hotbar-number {
            position: absolute;
            top: 3px;
            left: 3px;
            background-color: rgba(0, 0, 0, 0.7);
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        #minimap {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 120px;
            height: 120px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #4ecdc4;
            border-radius: 8px;
            z-index: 80;
            overflow: hidden;
        }
        
        .block {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 3px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .grass { background-color: #7CFC00; }
        .dirt { background-color: #8B4513; }
        .stone { background-color: #808080; }
        .wood { background-color: #8B7355; }
        .leaf { background-color: #32CD32; }
        .glass { background-color: rgba(173, 216, 230, 0.7); }
        .plank { background-color: #DEB887; }
        .stick { background-color: #D2B48C; }
        .coal { background-color: #333; }
        .iron { background-color: #C0C0C0; }
        .diamond { background-color: #4EE2EC; }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 90;
        }
        
        .crosshair-line {
            position: absolute;
            background-color: white;
        }
        
        .crosshair-horizontal {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }
        
        .crosshair-vertical {
            width: 2px;
            height: 20px;
            top: 0;
            left: 9px;
        }
        
        #debug-info {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 80;
            display: none;
        }
        
        .key-hint {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 90;
            animation: fadeOut 3s forwards;
        }
        
        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        @media (max-width: 1200px) {
            #sidebar {
                position: absolute;
                left: 0;
                top: 0;
                height: 100%;
                z-index: 100;
                transform: translateX(-100%);
            }
            
            #sidebar.open {
                transform: translateX(0);
            }
            
            #toggle-sidebar {
                display: flex;
            }
            
            .game-stats {
                flex-direction: column;
                gap: 8px;
            }
        }
        
        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
            }
            
            #minimap {
                width: 100px;
                height: 100px;
                top: 70px;
                right: 10px;
            }
            
            .hotbar-slot {
                width: 45px;
                height: 45px;
            }
            
            h1 {
                font-size: 20px;
            }
            
            .game-stats {
                font-size: 14px;
            }
            
            .key-hint {
                bottom: 150px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="header">
            <div class="logo">
                <div class="logo-icon">M</div>
                <h1>Minecraft Web</h1>
            </div>
            
            <div class="game-stats">
                <div class="stat-item">
                    <span class="stat-icon">‚õèÔ∏è</span>
                    <span>–ë–ª–æ–∫–∏: <span id="block-count">0</span></span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">üìç</span>
                    <span id="coordinates">X: 0, Y: 20, Z: 0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">‚è±Ô∏è</span>
                    <span id="game-time">–î–µ–Ω—å</span>
                </div>
            </div>
        </div>
        
        <div id="main-content">
            <div id="sidebar">
                <div class="sidebar-section" id="inventory">
                    <div class="section-title">–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</div>
                    <div class="inventory-slots" id="inventory-slots">
                        <!-- –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –±—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω—è—Ç—å—Å—è —á–µ—Ä–µ–∑ JavaScript -->
                    </div>
                </div>
                
                <div class="sidebar-section" id="crafting">
                    <div class="section-title">–ö—Ä–∞—Ñ—Ç</div>
                    <div class="crafting-grid" id="crafting-grid">
                        <!-- –°–ª–æ—Ç—ã –∫—Ä–∞—Ñ—Ç–∞ –±—É–¥—É—Ç –∑–∞–ø–æ–ª–Ω—è—Ç—å—Å—è —á–µ—Ä–µ–∑ JavaScript -->
                    </div>
                    <div id="craft-result">
                        <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç –∫—Ä–∞—Ñ—Ç–∞ -->
                    </div>
                    <button id="craft-btn" class="craft-btn" disabled>–°–æ–∑–¥–∞—Ç—å</button>
                </div>
                
                <div class="sidebar-section" id="player-info">
                    <div class="section-title">–ü–µ—Ä—Å–æ–Ω–∞–∂</div>
                    <div class="health-bar">
                        <div class="health-fill" id="health-bar" style="width: 100%"></div>
                        <div class="bar-label">–ó–¥–æ—Ä–æ–≤—å–µ: <span id="health-value">100</span></div>
                    </div>
                    <div class="food-bar">
                        <div class="food-fill" id="food-bar" style="width: 100%"></div>
                        <div class="bar-label">–°—ã—Ç–æ—Å—Ç—å: <span id="food-value">100</span></div>
                    </div>
                    <div style="margin-top: 12px; font-size: 14px;">
                        <div>–£—Ä–æ–≤–µ–Ω—å: <span id="player-level">1</span></div>
                        <div>–û–ø—ã—Ç: <span id="player-xp">0</span>/100</div>
                    </div>
                </div>
            </div>
            
            <div id="canvas-wrapper">
                <canvas id="game-canvas" tabindex="0"></canvas>
                
                <div id="crosshair">
                    <div class="crosshair-line crosshair-horizontal"></div>
                    <div class="crosshair-line crosshair-vertical"></div>
                </div>
                
                <div id="mobile-controls">
                    <div class="mobile-btn" id="mobile-left">‚Üê</div>
                    <div class="mobile-btn" id="mobile-up">‚Üë</div>
                    <div class="mobile-btn" id="mobile-right">‚Üí</div>
                    <div class="mobile-btn" id="mobile-down">‚Üì</div>
                    <div class="mobile-btn" id="mobile-jump">‚ò∞</div>
                    <div class="mobile-btn" id="mobile-action">‚ö°</div>
                </div>
                
                <div id="toggle-sidebar">‚ò∞</div>
                
                <div id="minimap"></div>
                
                <div id="hotbar">
                    <!-- –•–æ—Ç–±–∞—Ä –±—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω—è—Ç—å—Å—è —á–µ—Ä–µ–∑ JavaScript -->
                </div>
                
                <div id="debug-info"></div>
                
                <div id="key-hint" class="key-hint">–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —ç–∫—Ä–∞–Ω –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é</div>
            </div>
        </div>
    </div>
    
    <div id="loading-screen">
        <div class="loader"></div>
        <div class="loading-text">–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–∏—Ä–∞...</div>
        <div class="loading-subtext">Minecraft Web Edition</div>
        <div class="progress-bar">
            <div class="progress-fill" id="loading-progress"></div>
        </div>
        <div id="loading-status">–ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä...</div>
    </div>

    <!-- Three.js –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –ò–ì–†–´
        
        // –ò–ì–†–û–í–´–ï –ö–û–ù–°–¢–ê–ù–¢–´
        const CHUNK_SIZE = 16;
        const RENDER_DISTANCE = 3; // –ß–∞–Ω–∫–æ–≤ –≤ –∫–∞–∂–¥—É—é —Å—Ç–æ—Ä–æ–Ω—É
        const WORLD_HEIGHT = 32;   // –£–º–µ–Ω—å—à–∞–µ–º –≤—ã—Å–æ—Ç—É –º–∏—Ä–∞ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        
        // –¢–∏–ø—ã –±–ª–æ–∫–æ–≤ –∏ –∏—Ö —Å–≤–æ–π—Å—Ç–≤–∞
        const BLOCK_TYPES = {
            air: { id: 0, name: '–í–æ–∑–¥—É—Ö', color: 0x000000, transparent: true, solid: false },
            grass: { id: 1, name: '–¢—Ä–∞–≤–∞', color: 0x7CFC00, transparent: false, solid: true, durability: 1 },
            dirt: { id: 2, name: '–ó–µ–º–ª—è', color: 0x8B4513, transparent: false, solid: true, durability: 1 },
            stone: { id: 3, name: '–ö–∞–º–µ–Ω—å', color: 0x808080, transparent: false, solid: true, durability: 3 },
            wood: { id: 4, name: '–î–µ—Ä–µ–≤–æ', color: 0x8B7355, transparent: false, solid: true, durability: 2 },
            leaf: { id: 5, name: '–õ–∏—Å—Ç–≤–∞', color: 0x32CD32, transparent: true, solid: true, durability: 1 },
            glass: { id: 6, name: '–°—Ç–µ–∫–ª–æ', color: 0xADD8E6, transparent: true, solid: true, durability: 1 },
            plank: { id: 7, name: '–î–æ—Å–∫–∏', color: 0xDEB887, transparent: false, solid: true, durability: 2 },
            stick: { id: 8, name: '–ü–∞–ª–∫–∞', color: 0xD2B48C, transparent: false, solid: false, stackable: true }
        };

        // –†–µ—Ü–µ–ø—Ç—ã –∫—Ä–∞—Ñ—Ç–∞
        const CRAFTING_RECIPES = [
            {
                input: [[4, 0, 0], [0, 0, 0], [0, 0, 0]],
                output: { type: 7, count: 4 }
            },
            {
                input: [[0, 0, 0], [7, 0, 0], [7, 0, 0]],
                output: { type: 8, count: 4 }
            }
        ];

        // –ò–ì–†–û–í–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
        let scene, camera, renderer;
        let chunks = {}; // –ß–∞–Ω–∫–∏ –º–∏—Ä–∞
        let worldMeshes = {}; // 3D-–º–µ—à–∏ —á–∞–Ω–∫–æ–≤
        let player = {
            position: new THREE.Vector3(8, 25, 8),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: new THREE.Euler(0, 0, 0, 'YXZ'),
            health: 100,
            food: 100,
            level: 1,
            xp: 0,
            inventory: [],
            selectedSlot: 0,
            onGround: false,
            speed: 0.1,
            jumpForce: 0.15
        };
        
        let keys = {};
        let mouse = { x: 0, y: 0, down: false };
        let raycaster = new THREE.Raycaster();
        let dayTime = 0.25; // –£—Ç—Ä–æ
        let daySpeed = 0.00003;
        let blockCount = 0;
        let lastChunkX = -999, lastChunkZ = -999;
        let sunLight, ambientLight;
        let renderDistance = RENDER_DISTANCE;
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        async function initGame() {
            updateLoadingStatus('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è 3D...', 10);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.copy(player.position);
            camera.rotation.order = 'YXZ';
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('game-canvas'),
                antialias: false, // –û—Ç–∫–ª—é—á–∞–µ–º —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–∏–∫—Å–µ–ª—å–Ω–æ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ
            renderer.shadowMap.enabled = false; // –û—Ç–∫–ª—é—á–∞–µ–º —Ç–µ–Ω–∏ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ—Å–≤–µ—â–µ–Ω–∏—è
            setupLighting();
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –º–∏—Ä–∞
            updateLoadingStatus('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞...', 30);
            generateInitialWorld();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
            updateLoadingStatus('–ó–∞–≥—Ä—É–∑–∫–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞...', 70);
            initUI();
            initInventory();
            initCrafting();
            initHotbar();
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π
            setupEventListeners();
            
            // –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫—É
            setTimeout(() => {
                document.getElementById('key-hint').style.display = 'none';
            }, 3000);
            
            // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
            updateLoadingStatus('–ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã...', 90);
            setTimeout(() => {
                document.getElementById('loading-screen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading-screen').style.display = 'none';
                    // –§–æ–∫—É—Å–∏—Ä—É–µ–º –∫–∞–Ω–≤–∞—Å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
                    document.getElementById('game-canvas').focus();
                    // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
                    requestAnimationFrame(animate);
                }, 500);
            }, 500);
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ—Å–≤–µ—â–µ–Ω–∏—è
        function setupLighting() {
            // –°–æ–ª–Ω—Ü–µ
            sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(100, 100, 100);
            scene.add(sunLight);
            
            // –†–∞—Å—Å–µ—è–Ω–Ω—ã–π —Å–≤–µ—Ç
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –º–∏—Ä–∞ –≤–æ–∫—Ä—É–≥ –∏–≥—Ä–æ–∫–∞
        function generateInitialWorld() {
            const playerChunkX = Math.floor(player.position.x / CHUNK_SIZE);
            const playerChunkZ = Math.floor(player.position.z / CHUNK_SIZE);
            
            for (let x = playerChunkX - renderDistance; x <= playerChunkX + renderDistance; x++) {
                for (let z = playerChunkZ - renderDistance; z <= playerChunkZ + renderDistance; z++) {
                    generateChunk(x, z);
                }
            }
            
            lastChunkX = playerChunkX;
            lastChunkZ = playerChunkZ;
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–∞–Ω–∫–∞
        function generateChunk(chunkX, chunkZ) {
            const chunkKey = `${chunkX},${chunkZ}`;
            
            // –ï—Å–ª–∏ —á–∞–Ω–∫ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
            if (chunks[chunkKey]) return;
            
            // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –¥–ª—è —á–∞–Ω–∫–∞
            const chunk = new Array(CHUNK_SIZE);
            for (let x = 0; x < CHUNK_SIZE; x++) {
                chunk[x] = new Array(CHUNK_SIZE);
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    chunk[x][z] = new Array(WORLD_HEIGHT).fill(0);
                }
            }
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º —á–∞–Ω–∫
            const worldX = chunkX * CHUNK_SIZE;
            const worldZ = chunkZ * CHUNK_SIZE;
            
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const globalX = worldX + x;
                    const globalZ = worldZ + z;
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—ã—Å–æ—Ç—ã
                    const height = Math.floor(
                        10 + 
                        Math.sin(globalX * 0.1) * 2 + 
                        Math.cos(globalZ * 0.1) * 2 +
                        Math.sin(globalX * 0.05 + globalZ * 0.05) * 3
                    );
                    
                    const terrainHeight = Math.max(1, Math.min(WORLD_HEIGHT - 5, height));
                    
                    // –ó–∞–ø–æ–ª–Ω—è–µ–º –±–ª–æ–∫–∏
                    for (let y = 0; y < WORLD_HEIGHT; y++) {
                        if (y === terrainHeight - 1) {
                            chunk[x][z][y] = 1; // –¢—Ä–∞–≤–∞
                        } else if (y < terrainHeight - 1 && y >= terrainHeight - 4) {
                            chunk[x][z][y] = 2; // –ó–µ–º–ª—è
                        } else if (y < terrainHeight - 4) {
                            chunk[x][z][y] = 3; // –ö–∞–º–µ–Ω—å
                        } else {
                            chunk[x][z][y] = 0; // –í–æ–∑–¥—É—Ö
                        }
                    }
                    
                    // –î–µ—Ä–µ–≤—å—è
                    if (terrainHeight > 12 && Math.random() < 0.02) {
                        generateTreeInChunk(chunk, x, terrainHeight, z);
                    }
                }
            }
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —á–∞–Ω–∫
            chunks[chunkKey] = chunk;
            
            // –°–æ–∑–¥–∞–µ–º –º–µ—à –¥–ª—è —á–∞–Ω–∫–∞
            createChunkMesh(chunkX, chunkZ, chunk);
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–µ—Ä–µ–≤–∞ –≤ —á–∞–Ω–∫–µ
        function generateTreeInChunk(chunk, x, y, z) {
            const trunkHeight = 4;
            
            // –°—Ç–≤–æ–ª
            for (let i = 0; i < trunkHeight; i++) {
                if (y + i < WORLD_HEIGHT) {
                    chunk[x][z][y + i] = 4; // –î–µ—Ä–µ–≤–æ
                }
            }
            
            // –õ–∏—Å—Ç–≤–∞
            const leafStart = y + trunkHeight - 2;
            for (let ly = leafStart; ly <= leafStart + 2; ly++) {
                if (ly >= WORLD_HEIGHT) continue;
                
                for (let lx = Math.max(0, x - 2); lx <= Math.min(CHUNK_SIZE - 1, x + 2); lx++) {
                    for (let lz = Math.max(0, z - 2); lz <= Math.min(CHUNK_SIZE - 1, z + 2); lz++) {
                        // –ù–µ —Å—Ç–∞–≤–∏–º –ª–∏—Å—Ç–≤—É –≤ —É–≥–ª–∞—Ö –Ω–∞ –Ω–∏–∂–Ω–µ–º —É—Ä–æ–≤–Ω–µ
                        if (ly === leafStart && Math.abs(lx - x) === 2 && Math.abs(lz - z) === 2) {
                            continue;
                        }
                        
                        // –ù–µ —Å—Ç–∞–≤–∏–º –ª–∏—Å—Ç–≤—É –≤–º–µ—Å—Ç–æ —Å—Ç–≤–æ–ª–∞
                        if (lx === x && lz === z && ly <= y + trunkHeight) {
                            continue;
                        }
                        
                        // –°–ª—É—á–∞–π–Ω–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –±–ª–æ–∫–∏
                        if (Math.random() < 0.7) {
                            chunk[lx][lz][ly] = 5; // –õ–∏—Å—Ç–≤–∞
                        }
                    }
                }
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –º–µ—à–∞ –¥–ª—è —á–∞–Ω–∫–∞
        function createChunkMesh(chunkX, chunkZ, chunk) {
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.MeshLambertMaterial({ vertexColors: true });
            
            const vertices = [];
            const colors = [];
            const indices = [];
            let vertexCount = 0;
            
            const worldX = chunkX * CHUNK_SIZE;
            const worldZ = chunkZ * CHUNK_SIZE;
            
            // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º –±–ª–æ–∫–∞–º –≤ —á–∞–Ω–∫–µ
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const blockId = chunk[x][z][y];
                        if (blockId === 0) continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤–æ–∑–¥—É—Ö
                        
                        const blockType = Object.values(BLOCK_TYPES).find(b => b.id === blockId);
                        if (!blockType || blockType.transparent) continue;
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å–µ–¥–Ω–∏–µ –±–ª–æ–∫–∏ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
                        const px = getBlock(worldX + x + 1, y, worldZ + z);
                        const nx = getBlock(worldX + x - 1, y, worldZ + z);
                        const py = getBlock(worldX + x, y + 1, worldZ + z);
                        const ny = getBlock(worldX + x, y - 1, worldZ + z);
                        const pz = getBlock(worldX + x, y, worldZ + z + 1);
                        const nz = getBlock(worldX + x, y, worldZ + z - 1);
                        
                        const pxType = Object.values(BLOCK_TYPES).find(b => b.id === px);
                        const nxType = Object.values(BLOCK_TYPES).find(b => b.id === nx);
                        const pyType = Object.values(BLOCK_TYPES).find(b => b.id === py);
                        const nyType = Object.values(BLOCK_TYPES).find(b => b.id === ny);
                        const pzType = Object.values(BLOCK_TYPES).find(b => b.id === pz);
                        const nzType = Object.values(BLOCK_TYPES).find(b => b.id === nz);
                        
                        const blockColor = new THREE.Color(blockType.color);
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –≤–∏–¥–∏–º—ã–µ –≥—Ä–∞–Ω–∏
                        if (!pxType || pxType.transparent) addFace(vertices, colors, indices, vertexCount, 
                            worldX + x + 0.5, y - 0.5, worldZ + z - 0.5,
                            worldX + x + 0.5, y + 0.5, worldZ + z - 0.5,
                            worldX + x + 0.5, y + 0.5, worldZ + z + 0.5,
                            worldX + x + 0.5, y - 0.5, worldZ + z + 0.5,
                            blockColor);
                        
                        if (!nxType || nxType.transparent) addFace(vertices, colors, indices, vertexCount, 
                            worldX + x - 0.5, y - 0.5, worldZ + z + 0.5,
                            worldX + x - 0.5, y + 0.5, worldZ + z + 0.5,
                            worldX + x - 0.5, y + 0.5, worldZ + z - 0.5,
                            worldX + x - 0.5, y - 0.5, worldZ + z - 0.5,
                            blockColor);
                        
                        if (!pyType || pyType.transparent) addFace(vertices, colors, indices, vertexCount, 
                            worldX + x - 0.5, y + 0.5, worldZ + z - 0.5,
                            worldX + x + 0.5, y + 0.5, worldZ + z - 0.5,
                            worldX + x + 0.5, y + 0.5, worldZ + z + 0.5,
                            worldX + x - 0.5, y + 0.5, worldZ + z + 0.5,
                            blockColor);
                        
                        if (!nyType || nyType.transparent) addFace(vertices, colors, indices, vertexCount, 
                            worldX + x - 0.5, y - 0.5, worldZ + z + 0.5,
                            worldX + x + 0.5, y - 0.5, worldZ + z + 0.5,
                            worldX + x + 0.5, y - 0.5, worldZ + z - 0.5,
                            worldX + x - 0.5, y - 0.5, worldZ + z - 0.5,
                            blockColor);
                        
                        if (!pzType || pzType.transparent) addFace(vertices, colors, indices, vertexCount, 
                            worldX + x - 0.5, y - 0.5, worldZ + z + 0.5,
                            worldX + x - 0.5, y + 0.5, worldZ + z + 0.5,
                            worldX + x + 0.5, y + 0.5, worldZ + z + 0.5,
                            worldX + x + 0.5, y - 0.5, worldZ + z + 0.5,
                            blockColor);
                        
                        if (!nzType || nzType.transparent) addFace(vertices, colors, indices, vertexCount, 
                            worldX + x + 0.5, y - 0.5, worldZ + z - 0.5,
                            worldX + x + 0.5, y + 0.5, worldZ + z - 0.5,
                            worldX + x - 0.5, y + 0.5, worldZ + z - 0.5,
                            worldX + x - 0.5, y - 0.5, worldZ + z - 0.5,
                            blockColor);
                    }
                }
            }
            
            // –ï—Å–ª–∏ –≤ —á–∞–Ω–∫–µ –Ω–µ—Ç –±–ª–æ–∫–æ–≤, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –º–µ—à–∞
            if (vertices.length === 0) return;
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, 0, 0);
            scene.add(mesh);
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–µ—à
            worldMeshes[`${chunkX},${chunkZ}`] = mesh;
            
            blockCount += vertices.length / 12;
            document.getElementById('block-count').textContent = Math.floor(blockCount / 1000) + 'k';
        }
        
        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏ –∫—É–±–∞
        function addFace(vertices, colors, indices, vertexCount, 
                         x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, color) {
            // –í–µ—Ä—à–∏–Ω—ã
            vertices.push(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
            
            // –¶–≤–µ—Ç–∞
            for (let i = 0; i < 4; i++) {
                colors.push(color.r, color.g, color.b);
            }
            
            // –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –¥–≤—É—Ö —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤
            indices.push(
                vertexCount, vertexCount + 1, vertexCount + 2,
                vertexCount, vertexCount + 2, vertexCount + 3
            );
            
            vertexCount += 4;
        }
        
        // –ü–æ–ª—É—á–µ–Ω–∏–µ –±–ª–æ–∫–∞ –ø–æ –º–∏—Ä–æ–≤—ã–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
        function getBlock(x, y, z) {
            if (y < 0 || y >= WORLD_HEIGHT) return 0;
            
            const chunkX = Math.floor(x / CHUNK_SIZE);
            const chunkZ = Math.floor(z / CHUNK_SIZE);
            const chunkKey = `${chunkX},${chunkZ}`;
            
            if (!chunks[chunkKey]) {
                // –ï—Å–ª–∏ —á–∞–Ω–∫ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –µ–≥–æ
                generateChunk(chunkX, chunkZ);
                if (!chunks[chunkKey]) return 0;
            }
            
            const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            
            return chunks[chunkKey][localX][localZ][y] || 0;
        }
        
        // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–ª–æ–∫–∞
        function setBlock(x, y, z, blockId) {
            if (y < 0 || y >= WORLD_HEIGHT) return false;
            
            const chunkX = Math.floor(x / CHUNK_SIZE);
            const chunkZ = Math.floor(z / CHUNK_SIZE);
            const chunkKey = `${chunkX},${chunkZ}`;
            
            if (!chunks[chunkKey]) return false;
            
            const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–ª–æ–∫
            chunks[chunkKey][localX][localZ][y] = blockId;
            
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –º–µ—à —á–∞–Ω–∫–∞
            if (worldMeshes[chunkKey]) {
                scene.remove(worldMeshes[chunkKey]);
                delete worldMeshes[chunkKey];
            }
            
            // –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –º–µ—à —á–∞–Ω–∫–∞
            createChunkMesh(chunkX, chunkZ, chunks[chunkKey]);
            
            // –¢–∞–∫–∂–µ –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å —Å–æ—Å–µ–¥–Ω–∏–µ —á–∞–Ω–∫–∏, –µ—Å–ª–∏ –±–ª–æ–∫ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ
            updateNeighborChunks(chunkX, chunkZ, localX, localZ);
            
            return true;
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å–µ–¥–Ω–∏—Ö —á–∞–Ω–∫–æ–≤
        function updateNeighborChunks(chunkX, chunkZ, localX, localZ) {
            // –ï—Å–ª–∏ –±–ª–æ–∫ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ —Å —Å–æ—Å–µ–¥–Ω–∏–º —á–∞–Ω–∫–æ–º, –æ–±–Ω–æ–≤–ª—è–µ–º –∏ –µ–≥–æ
            if (localX === 0) {
                const neighborKey = `${chunkX - 1},${chunkZ}`;
                if (worldMeshes[neighborKey]) {
                    scene.remove(worldMeshes[neighborKey]);
                    delete worldMeshes[neighborKey];
                    createChunkMesh(chunkX - 1, chunkZ, chunks[neighborKey]);
                }
            }
            if (localX === CHUNK_SIZE - 1) {
                const neighborKey = `${chunkX + 1},${chunkZ}`;
                if (worldMeshes[neighborKey]) {
                    scene.remove(worldMeshes[neighborKey]);
                    delete worldMeshes[neighborKey];
                    createChunkMesh(chunkX + 1, chunkZ, chunks[neighborKey]);
                }
            }
            if (localZ === 0) {
                const neighborKey = `${chunkX},${chunkZ - 1}`;
                if (worldMeshes[neighborKey]) {
                    scene.remove(worldMeshes[neighborKey]);
                    delete worldMeshes[neighborKey];
                    createChunkMesh(chunkX, chunkZ - 1, chunks[neighborKey]);
                }
            }
            if (localZ === CHUNK_SIZE - 1) {
                const neighborKey = `${chunkX},${chunkZ + 1}`;
                if (worldMeshes[neighborKey]) {
                    scene.remove(worldMeshes[neighborKey]);
                    delete worldMeshes[neighborKey];
                    createChunkMesh(chunkX, chunkZ + 1, chunks[neighborKey]);
                }
            }
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        function initUI() {
            updatePlayerInfo();
            setInterval(updatePlayerInfo, 100);
            
            // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Å–∞–π–¥–±–∞—Ä–∞
            document.getElementById('toggle-sidebar').addEventListener('click', () => {
                document.getElementById('sidebar').classList.toggle('open');
            });
            
            // –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫—É
            setTimeout(() => {
                document.getElementById('key-hint').style.display = 'block';
            }, 1000);
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
        function initInventory() {
            const inventorySlots = document.getElementById('inventory-slots');
            inventorySlots.innerHTML = '';
            
            // –ù–∞—á–∞–ª—å–Ω—ã–π –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å
            player.inventory = [
                { type: 1, count: 20, name: '–¢—Ä–∞–≤–∞' },
                { type: 2, count: 30, name: '–ó–µ–º–ª—è' },
                { type: 3, count: 15, name: '–ö–∞–º–µ–Ω—å' },
                { type: 4, count: 10, name: '–î–µ—Ä–µ–≤–æ' },
                { type: 5, count: 0, name: '–õ–∏—Å—Ç–≤–∞' },
                { type: 6, count: 0, name: '–°—Ç–µ–∫–ª–æ' },
                { type: 7, count: 0, name: '–î–æ—Å–∫–∏' },
                { type: 8, count: 0, name: '–ü–∞–ª–∫–∞' }
            ];
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ—Ç–æ–≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
            player.inventory.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.index = index;
                
                if (item.count > 0) {
                    const blockType = Object.values(BLOCK_TYPES).find(b => b.id === item.type);
                    slot.innerHTML = `
                        <div class="block-preview" style="background-color: #${blockType.color.toString(16).padStart(6, '0')}"></div>
                        <div class="slot-name">${item.name}</div>
                        <div class="slot-count">${item.count}</div>
                    `;
                }
                
                slot.addEventListener('click', () => {
                    if (item.count > 0) {
                        player.selectedSlot = index;
                        updateHotbar();
                        updateInventoryUI();
                    }
                });
                
                inventorySlots.appendChild(slot);
            });
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è –≤ UI
        function updateInventoryUI() {
            const inventorySlots = document.querySelectorAll('.inventory-slot');
            
            player.inventory.forEach((item, index) => {
                const slot = inventorySlots[index];
                if (item.count > 0) {
                    const blockType = Object.values(BLOCK_TYPES).find(b => b.id === item.type);
                    slot.innerHTML = `
                        <div class="block-preview" style="background-color: #${blockType.color.toString(16).padStart(6, '0')}"></div>
                        <div class="slot-name">${item.name}</div>
                        <div class="slot-count">${item.count}</div>
                    `;
                    slot.style.display = 'flex';
                } else {
                    slot.innerHTML = '';
                    slot.style.display = 'flex';
                }
                
                // –í—ã–¥–µ–ª—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Å–ª–æ—Ç
                if (index === player.selectedSlot && item.count > 0) {
                    slot.classList.add('selected');
                } else {
                    slot.classList.remove('selected');
                }
            });
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫—Ä–∞—Ñ—Ç–∞
        function initCrafting() {
            const craftingGrid = document.getElementById('crafting-grid');
            craftingGrid.innerHTML = '';
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ—Ç–æ–≤ –∫—Ä–∞—Ñ—Ç–∞
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'crafting-slot';
                slot.dataset.index = i;
                craftingGrid.appendChild(slot);
            }
            
            // –ö–Ω–æ–ø–∫–∞ –∫—Ä–∞—Ñ—Ç–∞
            document.getElementById('craft-btn').addEventListener('click', performCrafting);
        }
        
        // –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫—Ä–∞—Ñ—Ç–∞
        function performCrafting() {
            const result = document.getElementById('craft-result').dataset.result;
            if (!result) return;
            
            const output = JSON.parse(result);
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å
            const existingItem = player.inventory.find(item => item.type === output.type);
            if (existingItem) {
                existingItem.count += output.count;
            } else {
                // –ò—â–µ–º –ø—É—Å—Ç–æ–π —Å–ª–æ—Ç
                const emptySlot = player.inventory.findIndex(item => item.count === 0);
                if (emptySlot !== -1) {
                    const blockType = Object.values(BLOCK_TYPES).find(b => b.id === output.type);
                    player.inventory[emptySlot] = { 
                        type: output.type, 
                        count: output.count,
                        name: blockType.name
                    };
                } else {
                    alert('–ù–µ—Ç –º–µ—Å—Ç–∞ –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ!');
                    return;
                }
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
            updateInventoryUI();
            updateHotbar();
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ö–æ—Ç–±–∞—Ä–∞
        function initHotbar() {
            const hotbar = document.getElementById('hotbar');
            hotbar.innerHTML = '';
            
            // –°–æ–∑–¥–∞–Ω–∏–µ 8 —Å–ª–æ—Ç–æ–≤ —Ö–æ—Ç–±–∞—Ä–∞
            for (let i = 0; i < 8; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot';
                slot.dataset.index = i;
                
                slot.innerHTML = `<div class="hotbar-number">${i + 1}</div>`;
                
                slot.addEventListener('click', () => {
                    selectHotbarSlot(i);
                });
                
                hotbar.appendChild(slot);
            }
            
            // –í—ã–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤—ã–π —Å–ª–æ—Ç
            selectHotbarSlot(0);
        }
        
        // –í—ã–±–æ—Ä —Å–ª–æ—Ç–∞ —Ö–æ—Ç–±–∞—Ä–∞
        function selectHotbarSlot(index) {
            player.selectedSlot = index;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
            document.querySelectorAll('.hotbar-slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            
            const selectedSlot = document.querySelector(`.hotbar-slot[data-index="${index}"]`);
            if (selectedSlot) {
                selectedSlot.classList.add('selected');
            }
            
            updateHotbar();
            updateInventoryUI();
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ö–æ—Ç–±–∞—Ä–∞
        function updateHotbar() {
            const hotbarSlots = document.querySelectorAll('.hotbar-slot');
            
            player.inventory.forEach((item, index) => {
                if (index >= hotbarSlots.length) return;
                
                const slot = hotbarSlots[index];
                if (item && item.count > 0) {
                    const blockType = Object.values(BLOCK_TYPES).find(b => b.id === item.type);
                    slot.innerHTML = `
                        <div class="hotbar-number">${index + 1}</div>
                        <div class="block-preview" style="background-color: #${blockType.color.toString(16).padStart(6, '0')}"></div>
                        <div class="slot-count" style="bottom: 2px; right: 3px; font-size: 10px;">${item.count}</div>
                    `;
                } else {
                    slot.innerHTML = `<div class="hotbar-number">${index + 1}</div>`;
                }
            });
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∏–≥—Ä–æ–∫–µ
        function updatePlayerInfo() {
            // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
            document.getElementById('coordinates').textContent = 
                `X: ${Math.floor(player.position.x)}, Y: ${Math.floor(player.position.y)}, Z: ${Math.floor(player.position.z)}`;
            
            // –ó–¥–æ—Ä–æ–≤—å–µ –∏ —Å—ã—Ç–æ—Å—Ç—å
            document.getElementById('health-value').textContent = player.health;
            document.getElementById('health-bar').style.width = `${player.health}%`;
            
            document.getElementById('food-value').textContent = player.food;
            document.getElementById('food-bar').style.width = `${player.food}%`;
            
            // –£—Ä–æ–≤–µ–Ω—å –∏ –æ–ø—ã—Ç
            document.getElementById('player-level').textContent = player.level;
            document.getElementById('player-xp').textContent = player.xp;
            
            // –í—Ä–µ–º—è —Å—É—Ç–æ–∫
            const timeText = dayTime < 0.25 ? '–ù–æ—á—å' : 
                            dayTime < 0.5 ? '–£—Ç—Ä–æ' : 
                            dayTime < 0.75 ? '–î–µ–Ω—å' : '–í–µ—á–µ—Ä';
            document.getElementById('game-time').textContent = timeText;
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–≥—Ä—É–∑–∫–∏
        function updateLoadingStatus(text, progress) {
            document.getElementById('loading-status').textContent = text;
            document.getElementById('loading-progress').style.width = `${progress}%`;
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π
        function setupEventListeners() {
            // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
            window.addEventListener('resize', onWindowResize);
            
            // –§–æ–∫—É—Å –Ω–∞ –∫–∞–Ω–≤–∞—Å–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
            document.getElementById('game-canvas').addEventListener('click', () => {
                document.getElementById('game-canvas').focus();
            });
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                
                // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Å–∞–π–¥–±–∞—Ä–∞
                if (key === 'e' || key === '—É') {
                    document.getElementById('sidebar').classList.toggle('open');
                    e.preventDefault();
                }
                
                // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç–ª–∞–¥–æ—á–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
                if (key === 'f3') {
                    document.getElementById('debug-info').style.display = 
                        document.getElementById('debug-info').style.display === 'none' ? 'block' : 'none';
                    e.preventDefault();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –º—ã—à–∏
            let mouseLocked = false;
            
            document.getElementById('game-canvas').addEventListener('click', () => {
                if (!mouseLocked) {
                    mouseLocked = true;
                    document.getElementById('game-canvas').requestPointerLock();
                    document.getElementById('key-hint').style.display = 'none';
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                mouseLocked = document.pointerLockElement === document.getElementById('game-canvas');
            });
            
            document.addEventListener('mousemove', (e) => {
                if (mouseLocked) {
                    // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã
                    player.rotation.y -= e.movementX * 0.002;
                    player.rotation.x -= e.movementY * 0.002;
                    
                    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç
                    player.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.rotation.x));
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –∫ –∫–∞–º–µ—Ä–µ
                    camera.rotation.set(player.rotation.x, player.rotation.y, 0);
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º—ã—à–∏ –¥–ª—è —Ä–µ–π–∫–∞—Å—Ç–µ—Ä–∞
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            
            document.addEventListener('mousedown', (e) => {
                if (mouseLocked) {
                    if (e.button === 0) { // –õ–ö–ú
                        removeBlock();
                    } else if (e.button === 2) { // –ü–ö–ú
                        placeBlock();
                    }
                    e.preventDefault();
                }
            });
            
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é
            document.addEventListener('contextmenu', e => e.preventDefault());
            
            // –ú–æ–±–∏–ª—å–Ω—ã–µ –∫–æ–Ω—Ç—Ä–æ–ª—ã
            if (window.innerWidth <= 768) {
                setupMobileControls();
            }
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–æ–ª–æ–≤
        function setupMobileControls() {
            const controls = ['left', 'up', 'right', 'down', 'jump', 'action'];
            
            controls.forEach(control => {
                const btn = document.getElementById(`mobile-${control}`);
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys[control] = true;
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys[control] = false;
                });
                
                btn.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    keys[control] = false;
                });
            });
        }
        
        // –£–¥–∞–ª–µ–Ω–∏–µ –±–ª–æ–∫–∞
        function removeBlock() {
            raycaster.setFromCamera(mouse, camera);
            
            // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –º–µ—à–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
            const meshes = Object.values(worldMeshes);
            const intersects = raycaster.intersectObjects(meshes);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const point = intersect.point.clone();
                
                // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –±–ª–æ–∫–∞
                const normal = intersect.face.normal.clone();
                point.sub(normal.multiplyScalar(0.5));
                
                const blockX = Math.floor(point.x);
                const blockY = Math.floor(point.y);
                const blockZ = Math.floor(point.z);
                
                // –ü–æ–ª—É—á–∞–µ–º —Ç–∏–ø –±–ª–æ–∫–∞
                const blockId = getBlock(blockX, blockY, blockZ);
                if (blockId === 0) return;
                
                const blockType = Object.values(BLOCK_TYPES).find(b => b.id === blockId);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –±–ª–æ–∫ –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å
                const existingItem = player.inventory.find(item => item.type === blockId);
                if (existingItem) {
                    existingItem.count++;
                } else {
                    // –ò—â–µ–º –ø—É—Å—Ç–æ–π —Å–ª–æ—Ç
                    const emptySlot = player.inventory.findIndex(item => item.count === 0);
                    if (emptySlot !== -1) {
                        player.inventory[emptySlot] = { 
                            type: blockId, 
                            count: 1,
                            name: blockType.name
                        };
                    }
                }
                
                // –£–¥–∞–ª—è–µ–º –±–ª–æ–∫ –∏–∑ –º–∏—Ä–∞
                setBlock(blockX, blockY, blockZ, 0);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
                updateInventoryUI();
                updateHotbar();
                
                // –î–∞–µ–º –æ–ø—ã—Ç
                player.xp += 2;
                if (player.xp >= 100) {
                    player.level++;
                    player.xp = player.xp - 100;
                    player.health = Math.min(100, player.health + 20);
                }
            }
        }
        
        // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–ª–æ–∫–∞
        function placeBlock() {
            const selectedItem = player.inventory[player.selectedSlot];
            if (!selectedItem || selectedItem.count <= 0) return;
            
            raycaster.setFromCamera(mouse, camera);
            const meshes = Object.values(worldMeshes);
            const intersects = raycaster.intersectObjects(meshes);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const point = intersect.point.clone();
                
                // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –Ω–æ–≤–æ–≥–æ –±–ª–æ–∫–∞
                const normal = intersect.face.normal.clone();
                point.add(normal.multiplyScalar(0.5));
                
                const blockX = Math.floor(point.x);
                const blockY = Math.floor(point.y);
                const blockZ = Math.floor(point.z);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –ø–æ—Å—Ç–∞–≤–∏—Ç—å –±–ª–æ–∫
                if (getBlock(blockX, blockY, blockZ) === 0) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –±–ª–æ–∫ –≤–Ω—É—Ç—Ä–∏ –∏–≥—Ä–æ–∫–∞
                    const playerMinX = Math.floor(player.position.x - 0.3);
                    const playerMaxX = Math.floor(player.position.x + 0.3);
                    const playerMinY = Math.floor(player.position.y);
                    const playerMaxY = Math.floor(player.position.y + 1.8);
                    const playerMinZ = Math.floor(player.position.z - 0.3);
                    const playerMaxZ = Math.floor(player.position.z + 0.3);
                    
                    if (blockX >= playerMinX && blockX <= playerMaxX &&
                        blockY >= playerMinY && blockY <= playerMaxY &&
                        blockZ >= playerMinZ && blockZ <= playerMaxZ) {
                        return; // –ù–µ —Å—Ç–∞–≤–∏–º –±–ª–æ–∫ –≤–Ω—É—Ç—Ä–∏ –∏–≥—Ä–æ–∫–∞
                    }
                    
                    // –°—Ç–∞–≤–∏–º –±–ª–æ–∫
                    if (setBlock(blockX, blockY, blockZ, selectedItem.type)) {
                        selectedItem.count--;
                        
                        if (selectedItem.count === 0) {
                            player.inventory[player.selectedSlot].count = 0;
                        }
                        
                        updateInventoryUI();
                        updateHotbar();
                    }
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞–Ω–∫–æ–≤ –≤–æ–∫—Ä—É–≥ –∏–≥—Ä–æ–∫–∞
        function updateChunksAroundPlayer() {
            const playerChunkX = Math.floor(player.position.x / CHUNK_SIZE);
            const playerChunkZ = Math.floor(player.position.z / CHUNK_SIZE);
            
            if (playerChunkX !== lastChunkX || playerChunkZ !== lastChunkZ) {
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ —á–∞–Ω–∫–∏
                for (let x = playerChunkX - renderDistance; x <= playerChunkX + renderDistance; x++) {
                    for (let z = playerChunkZ - renderDistance; z <= playerChunkZ + renderDistance; z++) {
                        const chunkKey = `${x},${z}`;
                        if (!chunks[chunkKey]) {
                            generateChunk(x, z);
                        }
                    }
                }
                
                // –£–¥–∞–ª—è–µ–º –¥–∞–ª—å–Ω–∏–µ —á–∞–Ω–∫–∏ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–∞–º—è—Ç–∏
                for (const chunkKey in chunks) {
                    const [x, z] = chunkKey.split(',').map(Number);
                    if (Math.abs(x - playerChunkX) > renderDistance + 1 || 
                        Math.abs(z - playerChunkZ) > renderDistance + 1) {
                        // –£–¥–∞–ª—è–µ–º –º–µ—à –∏–∑ —Å—Ü–µ–Ω—ã
                        if (worldMeshes[chunkKey]) {
                            scene.remove(worldMeshes[chunkKey]);
                            delete worldMeshes[chunkKey];
                        }
                        // –ú–æ–∂–Ω–æ —Ç–∞–∫–∂–µ —É–¥–∞–ª–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —á–∞–Ω–∫–∞, –Ω–æ –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–∏–º
                    }
                }
                
                lastChunkX = playerChunkX;
                lastChunkZ = playerChunkZ;
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
        function checkCollisions() {
            const pos = player.position;
            const vel = player.velocity;
            
            // –†–∞–∑–º–µ—Ä—ã –∏–≥—Ä–æ–∫–∞
            const width = 0.3;
            const height = 1.8;
            
            player.onGround = false;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å –±–ª–æ–∫–∞–º–∏
            for (let i = 0; i < 3; i++) {
                const checkPoints = [
                    // –ù–∏–∂–Ω–∏–µ —É–≥–ª—ã
                    {x: pos.x - width, y: pos.y - 0.1, z: pos.z - width},
                    {x: pos.x + width, y: pos.y - 0.1, z: pos.z - width},
                    {x: pos.x - width, y: pos.y - 0.1, z: pos.z + width},
                    {x: pos.x + width, y: pos.y - 0.1, z: pos.z + width},
                    // –í–µ—Ä—Ö–Ω–∏–µ —É–≥–ª—ã
                    {x: pos.x - width, y: pos.y + height, z: pos.z - width},
                    {x: pos.x + width, y: pos.y + height, z: pos.z - width},
                    {x: pos.x - width, y: pos.y + height, z: pos.z + width},
                    {x: pos.x + width, y: pos.y + height, z: pos.z + width}
                ];
                
                for (const point of checkPoints) {
                    const blockX = Math.floor(point.x + vel.x);
                    const blockY = Math.floor(point.y + vel.y);
                    const blockZ = Math.floor(point.z + vel.z);
                    
                    const blockId = getBlock(blockX, blockY, blockZ);
                    if (blockId !== 0) {
                        const blockType = Object.values(BLOCK_TYPES).find(b => b.id === blockId);
                        if (blockType && blockType.solid) {
                            // –ö–æ–ª–ª–∏–∑–∏—è –ø–æ Y (–ø–æ–ª)
                            if (vel.y < 0 && point.y <= pos.y + 0.1) {
                                player.position.y = blockY + 1.1;
                                vel.y = 0;
                                player.onGround = true;
                            }
                            // –ö–æ–ª–ª–∏–∑–∏—è –ø–æ Y (–ø–æ—Ç–æ–ª–æ–∫)
                            if (vel.y > 0 && point.y >= pos.y + height - 0.1) {
                                player.position.y = blockY - height;
                                vel.y = 0;
                            }
                            // –ö–æ–ª–ª–∏–∑–∏—è –ø–æ X
                            if (Math.abs(vel.x) > 0) {
                                vel.x = 0;
                            }
                            // –ö–æ–ª–ª–∏–∑–∏—è –ø–æ Z
                            if (Math.abs(vel.z) > 0) {
                                vel.z = 0;
                            }
                        }
                    }
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
        function updatePlayer(deltaTime) {
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏–µ–º
            const moveSpeed = player.speed * deltaTime * 60;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å
            player.velocity.x = 0;
            player.velocity.z = 0;
            
            // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ø–µ—Ä–µ–¥/–Ω–∞–∑–∞–¥
            if (keys['w'] || keys['—Ü'] || keys['up']) {
                player.velocity.x += forward.x * moveSpeed;
                player.velocity.z += forward.z * moveSpeed;
            }
            if (keys['s'] || keys['—ã'] || keys['down']) {
                player.velocity.x -= forward.x * moveSpeed;
                player.velocity.z -= forward.z * moveSpeed;
            }
            
            // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ
            if (keys['a'] || keys['—Ñ'] || keys['left']) {
                player.velocity.x -= right.x * moveSpeed;
                player.velocity.z -= right.z * moveSpeed;
            }
            if (keys['d'] || keys['–≤'] || keys['right']) {
                player.velocity.x += right.x * moveSpeed;
                player.velocity.z += right.z * moveSpeed;
            }
            
            // –ü—Ä—ã–∂–æ–∫
            if ((keys[' '] || keys['spacebar'] || keys['jump']) && player.onGround) {
                player.velocity.y = player.jumpForce;
                player.onGround = false;
            }
            
            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
            if (!player.onGround) {
                player.velocity.y -= 0.02 * deltaTime * 60;
            }
            
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –ø–∞–¥–µ–Ω–∏—è
            player.velocity.y = Math.max(player.velocity.y, -0.5);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
            checkCollisions();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
            player.position.x += player.velocity.x;
            player.position.y += player.velocity.y;
            player.position.z += player.velocity.z;
            
            // –ù–µ –¥–∞–µ–º –∏–≥—Ä–æ–∫—É —É–ø–∞—Å—Ç—å –Ω–∏–∂–µ –º–∏—Ä–∞
            if (player.position.y < 0) {
                player.position.y = 0;
                player.velocity.y = 0;
                player.onGround = true;
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫–∞–º–µ—Ä—ã
            camera.position.copy(player.position);
            camera.position.y += 1.6; // –í—ã—Å–æ—Ç–∞ –≥–ª–∞–∑
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞–Ω–∫–æ–≤ –≤–æ–∫—Ä—É–≥ –∏–≥—Ä–æ–∫–∞
            updateChunksAroundPlayer();
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫
            dayTime += daySpeed * deltaTime * 60;
            if (dayTime >= 1) dayTime = 0;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Å–≤–µ—â–µ–Ω–∏—è
            const sunIntensity = Math.max(0.3, Math.sin(dayTime * Math.PI * 2) * 0.5 + 0.5);
            sunLight.intensity = sunIntensity * 0.8;
            ambientLight.intensity = sunIntensity * 0.4;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ —Å–æ–ª–Ω—Ü–∞
            const sunAngle = dayTime * Math.PI * 2;
            sunLight.position.x = Math.cos(sunAngle) * 100;
            sunLight.position.y = Math.sin(sunAngle) * 50 + 50;
            sunLight.position.z = Math.sin(sunAngle) * 100;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ –Ω–µ–±–∞
            const skyColor = new THREE.Color();
            if (dayTime < 0.25 || dayTime > 0.75) {
                // –ù–æ—á—å
                skyColor.setHSL(0.7, 0.5, 0.1);
            } else if (dayTime < 0.5) {
                // –£—Ç—Ä–æ/–¥–µ–Ω—å
                const t = (dayTime - 0.25) * 4;
                skyColor.setHSL(0.6, 0.7, 0.5 + t * 0.3);
            } else {
                // –í–µ—á–µ—Ä
                const t = (0.75 - dayTime) * 4;
                skyColor.setHSL(0.05, 0.8, 0.4 + t * 0.2);
            }
            scene.fog.color.copy(skyColor);
            scene.background = skyColor;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
            updatePlayer(deltaTime);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–ª–∞–¥–æ—á–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
            updateDebugInfo(deltaTime);
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
            renderer.render(scene, camera);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–ª–∞–¥–æ—á–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
        function updateDebugInfo(deltaTime) {
            const debugInfo = document.getElementById('debug-info');
            if (debugInfo.style.display !== 'block') return;
            
            const fps = Math.round(1 / deltaTime);
            const chunksLoaded = Object.keys(chunks).length;
            const meshesLoaded = Object.keys(worldMeshes).length;
            
            debugInfo.innerHTML = `
                FPS: ${fps}<br>
                –ü–æ–∑–∏—Ü–∏—è: ${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}<br>
                –ß–∞–Ω–∫–æ–≤: ${chunksLoaded}<br>
                –ú–µ—à–µ–π: ${meshesLoaded}<br>
                –ë–ª–æ–∫–æ–≤: ~${Math.floor(blockCount / 1000)}k<br>
                –ù–∞ –∑–µ–º–ª–µ: ${player.onGround ? '–î–∞' : '–ù–µ—Ç'}
            `;
        }
        
        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
